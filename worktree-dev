#!/bin/bash
#
# worktree-dev - Git worktree manager with isolated Docker environments
#
# Creates git worktrees that can run docker-compose independently without
# port conflicts, container name collisions, or shared volumes.
#
# Usage:
#   worktree-dev create <branch-name>   # Create new worktree
#   worktree-dev list                   # List all worktrees
#   worktree-dev remove <branch-name>   # Remove worktree and cleanup
#   worktree-dev ports <branch-name>    # Show ports for a worktree
#
# Each worktree gets:
#   - Isolated Docker containers (unique COMPOSE_PROJECT_NAME)
#   - Unique ports (configurable base ports)
#   - Separate database volumes (fresh DB per worktree)
#   - Copy of .env with port overrides
#
# Requirements:
#   - Must be run from within a git repository
#   - Repository should have a docker-compose.yml with port variables like:
#       ports:
#         - "${DJANGO_PORT:-8000}:8000"
#

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Find the git repository root
find_repo_root() {
    git rev-parse --show-toplevel 2>/dev/null
}

REPO_ROOT=$(find_repo_root)
if [ -z "$REPO_ROOT" ]; then
    echo -e "${RED}Error: Not inside a git repository${NC}"
    exit 1
fi

REPO_NAME=$(basename "$REPO_ROOT")
WORKTREES_DIR="$REPO_ROOT/.worktrees"

# Calculate a stable port offset from branch name (1-99 range)
get_port_offset() {
    local branch="$1"
    local hash=$(echo "$branch" | cksum | cut -d' ' -f1)
    echo $(( (hash % 99) + 1 ))
}

# Sanitize branch name for use in Docker project name
sanitize_name() {
    echo "$1" | tr '/' '-' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]//g'
}

# Short project prefix from repo name
get_project_prefix() {
    local name="$1"
    # Take first 2 chars of each word, max 6 chars total
    echo "$name" | sed 's/-/ /g' | awk '{for(i=1;i<=NF;i++) printf substr($i,1,2)}' | cut -c1-6 | tr '[:upper:]' '[:lower:]'
}

# Detect port variables in docker-compose.yml
detect_port_vars() {
    local compose_file="$1"
    if [ -f "$compose_file" ]; then
        grep -oE '\$\{[A-Z_]+_PORT:-[0-9]+\}' "$compose_file" 2>/dev/null | \
            sed 's/\${//g; s/:-/ /g; s/}//g' | \
            sort -u
    fi
}

create_worktree() {
    local branch="$1"

    if [ -z "$branch" ]; then
        echo -e "${RED}Error: Branch name required${NC}"
        echo "Usage: worktree-dev create <branch-name>"
        exit 1
    fi

    local safe_name=$(sanitize_name "$branch")
    local worktree_path="$WORKTREES_DIR/$safe_name"
    local offset=$(get_port_offset "$safe_name")
    local prefix=$(get_project_prefix "$REPO_NAME")

    echo -e "${BLUE}Creating worktree for branch: ${YELLOW}$branch${NC}"
    echo -e "${BLUE}Repository: ${NC}$REPO_NAME"
    echo -e "${BLUE}Location: ${NC}$worktree_path"
    echo ""

    # Create worktrees directory if needed
    mkdir -p "$WORKTREES_DIR"

    # Add .worktrees to .gitignore if not already there
    if [ -f "$REPO_ROOT/.gitignore" ]; then
        if ! grep -q "^\.worktrees$" "$REPO_ROOT/.gitignore" 2>/dev/null; then
            echo -e "${BLUE}Adding .worktrees to .gitignore...${NC}"
            echo "" >> "$REPO_ROOT/.gitignore"
            echo "# Git worktrees with isolated Docker environments" >> "$REPO_ROOT/.gitignore"
            echo ".worktrees" >> "$REPO_ROOT/.gitignore"
        fi
    fi

    # Check if worktree already exists
    if [ -d "$worktree_path" ]; then
        echo -e "${YELLOW}Worktree already exists at $worktree_path${NC}"
        echo "Use 'worktree-dev remove $branch' first if you want to recreate it."
        exit 1
    fi

    # Check if branch is currently checked out
    local current_branch=$(git -C "$REPO_ROOT" branch --show-current)
    if [ "$current_branch" = "$branch" ]; then
        echo -e "${RED}Error: '$branch' is currently checked out in the main repo${NC}"
        echo "Switch to a different branch first, or create a worktree for a different branch."
        exit 1
    fi

    # Check if branch exists locally or remotely
    if ! git -C "$REPO_ROOT" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
        if git -C "$REPO_ROOT" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
            echo -e "${BLUE}Branch exists on remote, will track origin/$branch${NC}"
        else
            echo -e "${YELLOW}Branch '$branch' doesn't exist. Creating new branch from current HEAD...${NC}"
            git -C "$REPO_ROOT" branch "$branch"
        fi
    fi

    # Create the worktree
    echo -e "${BLUE}Creating git worktree...${NC}"
    git -C "$REPO_ROOT" worktree add "$worktree_path" "$branch"

    # Copy .env files
    for env_file in .env .env.local; do
        if [ -f "$REPO_ROOT/$env_file" ] && [ "$env_file" != ".env.local" ]; then
            echo -e "${BLUE}Copying $env_file...${NC}"
            cp "$REPO_ROOT/$env_file" "$worktree_path/$env_file"
        fi
    done

    # If no .env exists, try .env.example
    if [ ! -f "$worktree_path/.env" ] && [ -f "$REPO_ROOT/.env.example" ]; then
        echo -e "${YELLOW}No .env found, copying .env.example...${NC}"
        cp "$REPO_ROOT/.env.example" "$worktree_path/.env"
    fi

    # Detect ports from docker-compose.yml
    local compose_file="$REPO_ROOT/docker-compose.yml"
    local port_vars=""
    local port_exports=""
    local port_display=""

    if [ -f "$compose_file" ]; then
        echo -e "${BLUE}Detecting port configuration from docker-compose.yml...${NC}"
        while read -r var default; do
            if [ -n "$var" ]; then
                local new_port=$((default + offset))
                port_vars="${port_vars}${var}=$new_port\n"
                port_exports="${port_exports}export ${var}=\$${var}\n"
                port_display="${port_display}  ${var}: $new_port\n"
            fi
        done <<< "$(detect_port_vars "$compose_file")"
    fi

    # Create .env.local with port overrides and project name
    echo -e "${BLUE}Creating .env.local with isolated configuration...${NC}"
    cat > "$worktree_path/.env.local" << EOF
# Auto-generated by worktree-dev
# Repository: $REPO_NAME
# Worktree: $branch
# Created: $(date)

# Docker Compose project name (isolates containers, networks, and volumes)
COMPOSE_PROJECT_NAME=${prefix}-${safe_name}

# Port mappings (offset by $offset from defaults)
$(echo -e "$port_vars" | sed '/^$/d')
EOF

    # Create the dev helper script
    cat > "$worktree_path/dev" << DEVSCRIPT
#!/bin/bash
# Convenience script for this worktree
# Loads .env.local and runs docker-compose with proper isolation

set -e
SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"

# Load environment
if [ -f "\$SCRIPT_DIR/.env.local" ]; then
    set -a
    source "\$SCRIPT_DIR/.env.local"
    set +a
fi

# Show help
show_help() {
    echo "Worktree dev helper for: \$COMPOSE_PROJECT_NAME"
    echo ""
    echo "Commands:"
    echo "  up [services...]     Start services (default: all)"
    echo "  down                 Stop services"
    echo "  logs [service]       View logs (follows)"
    echo "  ps                   Show running containers"
    echo "  exec <svc> <cmd>     Execute command in service"
    echo "  run <svc> <cmd>      Run one-off command"
    echo "  build                Rebuild containers"
    echo "  restart [service]    Restart services"
    echo "  <any>                Passed to docker-compose"
    echo ""
    echo "Ports:"
$(echo -e "$port_display" | sed 's/^/    echo "/')
}

CMD="\${1:-help}"
shift 2>/dev/null || true

case "\$CMD" in
    up)
        echo "Starting \$COMPOSE_PROJECT_NAME..."
        docker-compose up -d "\$@"
        echo ""
        echo "Services started. Ports:"
$(echo -e "$port_display" | sed 's/^/        echo "/')
        ;;
    down)
        echo "Stopping \$COMPOSE_PROJECT_NAME..."
        docker-compose down "\$@"
        ;;
    logs)
        docker-compose logs -f "\$@"
        ;;
    ps)
        docker-compose ps "\$@"
        ;;
    exec)
        docker-compose exec "\$@"
        ;;
    run)
        docker-compose run --rm "\$@"
        ;;
    build)
        docker-compose build "\$@"
        ;;
    restart)
        docker-compose restart "\$@"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        docker-compose "\$CMD" "\$@"
        ;;
esac
DEVSCRIPT
    chmod +x "$worktree_path/dev"

    # Copy nested .env files (common patterns)
    for nested_env in services/*/.env apps/*/.env packages/*/.env; do
        if [ -f "$REPO_ROOT/$nested_env" ]; then
            local target_dir="$worktree_path/$(dirname "$nested_env")"
            if [ -d "$target_dir" ]; then
                cp "$REPO_ROOT/$nested_env" "$target_dir/"
            fi
        fi
    done

    echo ""
    echo -e "${GREEN}========================================${NC}"
    echo -e "${GREEN}Worktree created successfully!${NC}"
    echo -e "${GREEN}========================================${NC}"
    echo ""
    echo -e "${BLUE}Location:${NC}  $worktree_path"
    echo -e "${BLUE}Branch:${NC}    $branch"
    echo -e "${BLUE}Project:${NC}   ${prefix}-${safe_name}"
    echo ""
    if [ -n "$port_display" ]; then
        echo -e "${YELLOW}Ports allocated (offset +$offset):${NC}"
        echo -e "$port_display"
    fi
    echo -e "${YELLOW}Quick start:${NC}"
    echo "  cd $worktree_path"
    echo "  ./dev up              # Start services"
    echo "  ./dev logs            # View logs"
    echo "  ./dev down            # Stop services"
    echo ""
}

list_worktrees() {
    echo -e "${BLUE}Worktrees for ${CYAN}$REPO_NAME${NC}:"
    echo ""

    local found=0
    git -C "$REPO_ROOT" worktree list | while read -r line; do
        local path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')

        if [[ "$path" == *".worktrees"* ]]; then
            found=1
            local safe_name=$(basename "$path")
            local prefix=$(get_project_prefix "$REPO_NAME")
            local project="${prefix}-${safe_name}"

            # Check if containers are running
            local running=$(docker ps --filter "name=${project}" --format '{{.Names}}' 2>/dev/null | wc -l | tr -d ' ')

            if [ "$running" -gt 0 ]; then
                echo -e "  ${GREEN}●${NC} $branch"
                echo "    Path: $path"
                echo "    Project: $project ($running containers running)"
            else
                echo -e "  ${YELLOW}○${NC} $branch"
                echo "    Path: $path"
                echo "    Project: $project (stopped)"
            fi
            echo ""
        elif [[ "$path" == "$REPO_ROOT" ]]; then
            echo -e "  ${BLUE}◆${NC} $branch ${CYAN}(main repo)${NC}"
            echo "    Path: $path"
            echo ""
        fi
    done

    if [ "$found" -eq 0 ]; then
        echo -e "  ${YELLOW}No worktrees created yet.${NC}"
        echo "  Run: worktree-dev create <branch-name>"
        echo ""
    fi
}

remove_worktree() {
    local branch="$1"

    if [ -z "$branch" ]; then
        echo -e "${RED}Error: Branch name required${NC}"
        echo "Usage: worktree-dev remove <branch-name>"
        exit 1
    fi

    local safe_name=$(sanitize_name "$branch")
    local worktree_path="$WORKTREES_DIR/$safe_name"
    local prefix=$(get_project_prefix "$REPO_NAME")
    local project="${prefix}-${safe_name}"

    if [ ! -d "$worktree_path" ]; then
        echo -e "${RED}Error: Worktree not found at $worktree_path${NC}"
        exit 1
    fi

    echo -e "${YELLOW}Removing worktree: $branch${NC}"

    # Stop and remove Docker containers and volumes
    echo -e "${BLUE}Stopping Docker containers and removing volumes...${NC}"
    (cd "$worktree_path" && COMPOSE_PROJECT_NAME="$project" docker-compose down -v 2>/dev/null) || true

    # Remove any remaining containers with this project name
    docker ps -a --filter "name=${project}" --format '{{.ID}}' 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true

    # Remove worktree
    echo -e "${BLUE}Removing git worktree...${NC}"
    git -C "$REPO_ROOT" worktree remove "$worktree_path" --force 2>/dev/null || rm -rf "$worktree_path"

    # Prune worktree references
    git -C "$REPO_ROOT" worktree prune

    echo -e "${GREEN}Worktree '$branch' removed successfully!${NC}"
}

show_ports() {
    local branch="$1"

    if [ -z "$branch" ]; then
        echo -e "${RED}Error: Branch name required${NC}"
        echo "Usage: worktree-dev ports <branch-name>"
        exit 1
    fi

    local safe_name=$(sanitize_name "$branch")
    local offset=$(get_port_offset "$safe_name")
    local compose_file="$REPO_ROOT/docker-compose.yml"

    echo -e "${BLUE}Ports for branch: ${YELLOW}$branch${NC} (offset +$offset)"
    echo ""

    if [ -f "$compose_file" ]; then
        while read -r var default; do
            if [ -n "$var" ]; then
                echo "  $var: $((default + offset))"
            fi
        done <<< "$(detect_port_vars "$compose_file")"
    else
        echo -e "${YELLOW}No docker-compose.yml found${NC}"
    fi
}

show_help() {
    echo -e "${CYAN}worktree-dev${NC} - Git worktree manager with isolated Docker environments"
    echo ""
    echo "Usage:"
    echo "  worktree-dev create <branch>    Create new isolated worktree"
    echo "  worktree-dev list               List all worktrees with status"
    echo "  worktree-dev remove <branch>    Remove worktree and cleanup Docker"
    echo "  worktree-dev ports <branch>     Show ports that would be allocated"
    echo ""
    echo "Examples:"
    echo "  worktree-dev create feature/new-api"
    echo "  worktree-dev create fix/auth-bug"
    echo "  worktree-dev remove feature/new-api"
    echo ""
    echo "Each worktree gets:"
    echo "  - Isolated Docker containers (unique COMPOSE_PROJECT_NAME)"
    echo "  - Unique host ports (auto-detected from docker-compose.yml)"
    echo "  - Separate volumes (fresh database per worktree)"
    echo "  - A ./dev helper script for common commands"
    echo ""
    echo "Requirements:"
    echo "  - docker-compose.yml with port variables like: \${PORT_VAR:-default}"
    echo "  - Example: ports: - \"\${DJANGO_PORT:-8000}:8000\""
}

# Main command handler
case "${1:-}" in
    create)
        create_worktree "$2"
        ;;
    list|ls)
        list_worktrees
        ;;
    remove|rm)
        remove_worktree "$2"
        ;;
    ports)
        show_ports "$2"
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        echo ""
        show_help
        exit 1
        ;;
esac
